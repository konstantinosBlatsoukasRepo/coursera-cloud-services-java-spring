web contrainer (the machine that contains the servlets)
servlet (request processing happens): a java object that is able to handle http requests
web.xml (servlet router): tells which servlet is going to handle an http requests

HttpServlet, doGet...(HttpServletRequest, HttpServletResponse)

web.xml
    web-app

        servlet
            servlet-name
            servlet-name

        servlet-mapping
            servlet-name
            url pattern

Injenction attacks (malicious messages, for example js code)
solution: VALIDATE

treat client data as an attack

Spring Dispatcher Servlet and controller abstraction

    extract params from request

    validation

    construct objs ...

Spring and other framework does those things for you

Dispathcer servlet (a router): 
    
    - registers controllers (POJOS)


@Controller
public class ContactsController {

    @RequestMapping("/contacts")
    public Contacts get() {
        return ....;
    }
}


Extract data:

    @RequestParam -- things after the url that begins with ?name=kostas
    @RequestParam('x') string name,
    ...

    @RequestParam('x/{id}')
    @PathVariable("id") int myId


    json: 
        search(@RequestBody Search search) {
            do beautiful stuff
        }


    handling multipart data

    MultipartFile type: dealing with huge files



week3:

    - @ResponseBody: this is the body that response is going to ResponseBody

      public @ResponseBody getVideo....

    - Custom Marshalling/deserialization with Jackson(objectMapper) Annotations

        @JsonIngore

    - spring architecture

      dispatcher (web.xml) -> controllers

      set up web contrainer (jetty, tomcat)

      spring boot automates all the set up

      Application.java -> we can define a configuration for our app

      What spring boot does for us:

        1. set up contrainer
        2. controllers discovery
        3. set up dispatcher
        4. conencting DB...

    Spring controller:

        @Controller

        @RequestMapping(value="sasad/ ", method = GET...)
        public @ResponseBody ... (@RequestBody) 
        @RequestBody
        @ResponseBody


        no web.xml -> replaced by 


            @Configuration
            @EnableWebMvc: setting up dispatcher HttpServletRequest
            @ComponentScan: class discovery
            @EnableAutoConfiguration

        horizontal scaling:

            1. add more servers
            2. making apps stateless


        load balancing stateless vs statefull:

            1. load balancer (round robin: each machine must be stateless)
            remember client-machine

            sticky sessions

            in memory cache

            DB that shares info

            auto-scaling: add/remove machines

        Iaas n Paas:

            Iaas: bound to a machine, like vm (responsible for monitoring...)
            Pass: you just provide the code (all the others are left to cloud provider)

            do it your self VS provider

                cost? provider is cheaper



        spring dependency injection and auto-wiring:

             - @Autowired: spring tries to find an implementation

             - how spring resolves a dependencies:


                1. 
                    example: StorageSystem - LocalStorageSystem


                    @Configuration
                    public class .. {

                        @bean // this is a singlenton
                        public StorageSystem getStorageSystem() {
                            return new LocalStorageSystem();
                        }
                    }

                2.

                    @EnableAutoConfiguration --> find @Autowire and replace concrete implementations

                    @ComponentScan -> downside, may take a while at the app start up 


week 4: 

    Object Relational Mapping (ORM)
    Java persistence API (JPA)


    @Entity
    public class Video {

        @id
        @GeneratedValue(strategy: autogenerated)
        private long id;

        private String name;

    }



    Spring repositories

    public interface VideoRepo extends CrudRepository<Video, Long>
    {

        public List<Video> findByName(String);

            find ByName: query by name

        public List<Video> findByNameAndCategory(String a, String ctr);

    }


    Understanding SQL injenction attack